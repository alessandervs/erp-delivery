
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
// biome-ignore-all lint: generated file

Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  skip,
  Decimal,
  Debug,
  DbNull,
  JsonNull,
  AnyNull,
  NullTypes,
  makeStrictEnum,
  Extensions,
  warnOnce,
  defineDmmfProperty,
  Public,
  getRuntime,
  createParam,
} = require('./runtime/wasm-compiler-edge.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
Prisma.prismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = DbNull
Prisma.JsonNull = JsonNull
Prisma.AnyNull = AnyNull

Prisma.NullTypes = NullTypes





/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  Serializable: 'Serializable'
});

exports.Prisma.ClientScalarFieldEnum = {
  id: 'id',
  name: 'name',
  phone: 'phone',
  address: 'address',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};

exports.Prisma.OrderScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  clientId: 'clientId',
  channel: 'channel',
  product: 'product',
  info: 'info',
  deliveryPerson: 'deliveryPerson',
  paymentMethod: 'paymentMethod',
  value: 'value',
  message: 'message',
  deliveryMsg: 'deliveryMsg',
  snapshotAddress: 'snapshotAddress',
  snapshotPhone: 'snapshotPhone',
  snapshotName: 'snapshotName'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.NullsOrder = {
  first: 'first',
  last: 'last'
};


exports.Prisma.ModelName = {
  Client: 'Client',
  Order: 'Order'
};
/**
 * Create the Client
 */
const config = {
  "previewFeatures": [],
  "clientVersion": "7.2.0",
  "engineVersion": "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
  "activeProvider": "sqlite",
  "inlineSchema": "generator client {\n  provider = \"prisma-client-js\"\n  output   = \"../generated/prisma_client\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n}\n\nmodel Client {\n  id        Int      @id @default(autoincrement())\n  name      String   @unique\n  phone     String?\n  address   String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  orders    Order[]\n}\n\nmodel Order {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n\n  clientId Int\n  client   Client @relation(fields: [clientId], references: [id])\n\n  // Snapshot data (in case client changes, order history stays same? \n  // Or do we rely on relation? Usually safer to keep snapshot for orders but user wants relation)\n  // User asked to \"relate clients and orders\". \n  // Let's keep snapshot scalar fields for the receipt logic if needed, \n  // OR just use the relation. \n  // However, the \"OrderForm\" logic relies on specific textual fields for the \"message\".\n  // Let's keep the fields on Order for the \"receipt\" data, but link to Client for history.\n\n  channel        String\n  product        String\n  info           String?\n  deliveryPerson String?\n  paymentMethod  String\n  value          Float\n  message        String?\n  deliveryMsg    String?\n\n  // Snapshots for history accuracy if client moves?\n  // For simplicity and user request, we link them. \n  // But wait, the form has \"clientName\", \"phone\", \"address\".\n  // If I update client, do old orders change? \n  // Usually in food/delivery apps, you want the address *at that time*.\n  // But relational model implies normalizing.\n  // I will add the relation but ALSO keep the snapshot data used for the specific delivery,\n  // because a client might have multiple addresses over time or order for a friend.\n  // Actually, the user wants to \"Create a model Client\".\n\n  snapshotAddress String // Address where THIS order went\n  snapshotPhone   String // Phone used for THIS order\n  snapshotName    String // Name used\n}\n"
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"Client\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"phone\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"address\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"orders\",\"kind\":\"object\",\"type\":\"Order\",\"relationName\":\"ClientToOrder\"}],\"dbName\":null},\"Order\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\"},{\"name\":\"clientId\",\"kind\":\"scalar\",\"type\":\"Int\"},{\"name\":\"client\",\"kind\":\"object\",\"type\":\"Client\",\"relationName\":\"ClientToOrder\"},{\"name\":\"channel\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"product\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"info\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"deliveryPerson\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"paymentMethod\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"value\",\"kind\":\"scalar\",\"type\":\"Float\"},{\"name\":\"message\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"deliveryMsg\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"snapshotAddress\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"snapshotPhone\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"snapshotName\",\"kind\":\"scalar\",\"type\":\"String\"}],\"dbName\":null}},\"enums\":{},\"types\":{}}")
defineDmmfProperty(exports.Prisma, config.runtimeDataModel)
config.compilerWasm = {
  getRuntime: async () => require('./query_compiler_bg.js'),
  getQueryCompilerWasmModule: async () => {
    const loader = (await import('#wasm-compiler-loader')).default
    const compiler = (await loader).default
    return compiler
  }
}
if (typeof globalThis !== 'undefined' && globalThis['DEBUG'] || (typeof process !== 'undefined' && process.env && process.env.DEBUG) || undefined) {
  Debug.enable(typeof globalThis !== 'undefined' && globalThis['DEBUG'] || (typeof process !== 'undefined' && process.env && process.env.DEBUG) || undefined)
}

const PrismaClient = getPrismaClient(config)
exports.PrismaClient = PrismaClient
Object.assign(exports, Prisma)
